<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<chapter xml:id="commons-base" xmlns:xlink="http://www.w3.org/1999/xlink">
    <title>Commons Base</title>
    
    <section xml:id="commons-base-overview">
        <title>Overview</title>
        
        <para>This module was inspired by the Apache Commons project. It's initial 
        intention was to adapt and complement it (for example by adding some 
        generic features to the collections classes). As time has gone by  it
        grew and we added some features that we found useful for developing.  
        </para>
        <para><emphasis role="bold">Commons Base</emphasis> can be divided in:
        </para>
        <itemizedlist>
            <listitem><para><emphasis role="bold">Functors
            </emphasis>: Objects that encapsulates functional logic.</para></listitem>            
            <listitem><para><emphasis role="bold">Exceptions
            </emphasis>: Most used exceptions.</para></listitem>
            <listitem><para><emphasis role="bold">General Purpose Classes
            </emphasis>: Handling ordering and paging in 
            collections and rankeable results.</para></listitem>
            <listitem><para><emphasis role="bold">Secret Handling
            </emphasis>: Secret's generation (generated random value for 
            unique secure actions).</para></listitem>
            <listitem><para><emphasis role="bold">Resources
            </emphasis>: Abstractions for resources.</para></listitem>
            <listitem><para><emphasis role="bold">Collections
            </emphasis>: Handling collections.</para></listitem>
	        <listitem><para><emphasis role="bold">Storage
            </emphasis>: Searching and fetching information</para></listitem>
            <listitem><para><emphasis role="bold">Other utils
            </emphasis>: Validation, Date, String and Password Encoders utils.</para></listitem>
        </itemizedlist>
        
        <note>
	        <title>Dependencies</title>
	        <para><emphasis role="bold">Commons Base</emphasis>
	            has no dependencies like Spring or other mayor technologies.</para>
        </note>
    </section>

    <section xml:id="commons-base-functors">
        <title>Functors</title>
        
        <!-- basado de http://www.discursive.com/books/cjcook/reference/functors.html-->
        
        <!-- TODO Change this, almost verbatim -->
        
        <para>A functor is an object that performs an operation or function or
        "something that does stuff". As it's definition is so vague, it can be
        made to fit almost everything. The important thing about a functor is
        that encapsulates "functional logic", a gives us the posibility
        to approach programming with a set of small components that can be use 
        and combined as needed. So if we need to go through every element in 
        a collection we obtain an <code>Iterator</code> of this collection. 
        Then if we also have to perform an action on every element we add a 
        <code>Closure</code> to do it and so on.</para>
        <para>In <emphasis role="bold">Zauber Commons</emphasis> we can find 
        <code>Predicate</code>, <code>Transformer</code> and <code>Closure</code> 
        functors which were taken from <emphasis role="bold">Apache Commons</emphasis> 
        adding types to their definitions (making use of Java Generics). </para>
        
        <!-- Based on: http://www.discursive.com/books/cjcook/reference/functors-sect-simple-pred.html-->
        <section xml:id="commons-base-functors-predicate">
            <title>Predicates</title>
            <section xml:id="commons-base-functors-predicate-problem">
                <title>Problem</title>
                <para>You need to perform logic that is predicated on a certain 
                condition being satisfied, and you want to encapsulate this 
                condition in an object.</para>
            </section>
            <section xml:id="commons-base-functors-predicate-solution">
                <title>Solution</title>
                <para>Use a <code>Predicate</code> to evaluate a criteria or a condition. A 
                <code>Predicate</code> is an object that evaluates another object and returns 
                true or false. This code demonstrates the use of 
                simple predicates to test the type and contents of an object:</para>

                <programlisting language="Java">
import ar.com.zauber.commons.base.Predicate;
import ar.com.zauber.commons.base.predicate.*;
String name = "Shirley";
Predicate&lt;String&gt; nameEmma = new EqualsPredicate( "Emma" );
Predicate&lt;String&gt; nameShirley = new EqualsPredicate( "Shirley" );
// Testing all predicates for "Shirley"
System.out.println( "Is Name Emma?: " + nameEmma.evaluate( name ) );
System.out.println( "Is Name Shirley?: " + nameShirley.evaluate( name ) );</programlisting>
                
                <para>The previous example tests the name object against a few 
                Predicate implementations producing the following console output:</para>

                <programlisting language="Java">
Is Name Emma?: false
Is Name Shirley?: true</programlisting>

                <para>The string "Shirley" is subjected to <code>EqualsPredicate</code> 
                which test the contents of the string, returning true if the object 
                being evaluated is equal to the object passed into the 
                <code>EqualPredicate</code>'s constructor.</para>
                
            </section>
            
            <section xml:id="commons-base-functors-predicate-discussion">
                <title>Discussion</title>
                <para>A Predicate is a function object (or functor) that captures a 
                criteria in an object that can be created and altered at runtime.
                </para>
                <para>The <code>Predicate</code> interface define an 
                <code>evaluate(value)</code> method that returns a boolean. 
                This boolean is obtained by evaluating the <code>value</code> 
                with the <code>Predicate</code>'s criteria. A client class can 
                use and object defined by this interface and in runtime determine
                the actual implementation and even changing it thus changing 
                the evaluation criteria on runtime.
                </para>
                <para>This interface is central to a number of utilities related 
                with collections like filtering, selecting, and validating. But 
                also is helpfull in any number of situation where the behaviuor
                of the applications changes a lot.
                </para>
                
                <para><emphasis role="bold">Zauber Commons Base</emphasis> 
                provides a number of basic predicates for common situations. 
                Table 5.1 lists a number of simple 
                <code>Predicate</code> implementations.</para>

                <table frame='hsides'>
                    <title>Predicate implementations</title>
                
                    <tgroup cols="2">
                        <thead>
                            <row>
                                <entry align="center">Name</entry>
                                <entry align="center">Description</entry>
                            </row>
                        </thead>

                        <tbody>
                            <row>
                                <entry><code>EqualsPredicate</code></entry>
                                <entry>Compares the object to an object passed via a 
                                constructor, returning true if the two are equal.</entry>
                            </row>
							<row>
								<entry>
									<code>NotPredicate</code>
								</entry>
								<entry>Wraps a Predicate and returns the opposite result.</entry>
							</row>
							<row>
								<entry>
									<code>TruePredicate</code>
								</entry>
								<entry>Always returns true.</entry>
							</row>
							<row>
								<entry>
									<code>FalsePredicate</code>
								</entry>
								<entry>Always returns false.</entry>
							</row>
							<row>
								<entry>
									<code>AndPredicate</code>
								</entry>
								<entry>Takes a list of predicates by constructor and makes an And
									operation between them and the object passed via parameter.</entry>
							</row>
							<row>
								<entry>
									<code>IgnoreCaseEqualsPredicate</code>
								</entry>
								<entry>Compares String passed via constructor with argument ignoring
									case.</entry>
							</row>
							<row>
								<entry>
									<code>InPredicate</code>
								</entry>
								<entry>Returns true if the object is in the list passed via
									constructor.</entry>
							</row>
							<row>
								<entry>
									<code>ThrowableMaxAmountPredicate</code>
								</entry>
								<!-- Taken from -->
								<!-- https://wiki.zaubersoftware.com/intra/bin/view/Commons/ReleasesNotes3Punto21 -->
								<entry><code>Predicate</code> with type 
								<code>Collection&lt;Throwable&gt;</code> and returns 
								true if the amount of throwables exceeds the parameter 
								passed via constructor. Useful to combine with the 
								triggered exception builder for having a builder that
								allows a certain amount of exceptions and then throws
								an exception (use case e.x: network dependent routines).</entry>
							</row>                    
							
						</tbody>
					</tgroup>
                </table>
            </section>
        </section>
        
        <!-- Based on: http://www.discursive.com/books/cjcook/reference/functors-sect-transforming-objects.html -->
        <section xml:id="commons-base-functors-transformer">
            <title>Transformers</title>
            <section xml:id="commons-base-functors-transformer-problem">
                <title>Problem</title>
                
                <para>You need to perform a transformation, taking an object and 
                creating a new object.</para>
                
            </section>
            
            <section xml:id="commons-base-functors-transformer-solution">
                <title>Solution</title>
                
                <para>Implement the Transformer interface.  The following example 
                demonstrates the joinArmy <code>Transformer</code>; the <code>transform( )</code> 
                method takes a <code>Recruit</code> object instance and returns a 
                <code>Soldier</code> object:</para>
                
<programlisting language="Java">
import ar.com.zauber.commons.base.Transformer;
Transformer&lt;Recruit, Soldier&gt; joinArmy = new Transformer( ) {
    public Soldier transform(Recruit input) {
                BootCamp.obstacleCourse( input );
                Soldier soldier = BootCamp.graduate( recruit );
                return soldier;
        }
}
Recruit recruit1 = new Recruit("Pat T.");
System.out.println( "Status before transformation: " + recruit );
Soldier soldier1 = joinArmy.transform( recruit1 );
System.out.println( "Status after transformation: " + soldier );</programlisting>

                <para>The state of the recruit and soldier instances are printed 
                before and after the transformation:</para>

<programlisting language="Java">
Status before transformation: Pat T., Recruit
Status after transformation: Pat T., Soldier</programlisting>

            </section>
            
            <section xml:id="commons-base-functors-transformer-discussion">
                <title>Discussion</title>
                
				<para>This object isolates and encapsulates a transition; a 
				system that needs to translate between two domain models or two 
				object types should encapsulate such a transition in a <code>Transformer</code>. 
				<code>Transformer</code>  may be something of a misnomer. When an object 
				undergoes a transformation, it is common to think of an object 
				being modified or acted upon, but this is contrary to the design 
				of the Transformer interface. The Javadoc for <code>Transformer</code> expressly 
				states, "The original object is left unchanged."</para>

            </section>    
                    
        </section>
        
        <!-- Based on: http://www.discursive.com/books/cjcook/reference/functors-sect-writing-closure.html-->
        <section xml:id="commons-base-functors-closure">
            <title>Closures</title>
            <section xml:id="commons-base-functors-closure-problem">
                <title>Problem</title>
                <para>You to operate on an object.</para>
            </section>
            <section xml:id="commons-base-functors-closure-solution">
                <title>Solution</title>
                
                <para>Use a Closure to encapsulate a block of code that acts on 
                an object. In this example, a discount <code>Closure</code> operates 
                on a <code>Product</code> object, reducing the price by 10 percent:</para>

<programlisting language="Java">
Closure discount = new Closure( ) {
    int count = 0;
    public int getCount( ) { return count; }

    public void execute(Object input) {
        count++;
            (Product) product = (Product) input;
            product.setPrice( product.getPrice( ) * 0.90 );
    }
}
Product shoes = new Product( );
shoes.setName( "Fancy Shoes" );
shoes.setPrice( 120.00 );
System.out.println( "Shoes before discount: " + shoes );
discount.execute( shoes );
System.out.println( "Shoes after discount: " + shoes );
discount.execute( shoes );
discount.execute( shoes );
System.out.println( "Shoes after " + discount.getcount( ) +
                    " discounts: " + shoes );</programlisting>

                <para>The example prints out the original cost of shoes ($120) and 
                then proceeds to discount shoes and print out the discounted price. 
                The <code>Product</code> object, shoes, is modified by the discount <code>Closure</code> 
                three separate times:</para>

                <programlisting language="Java">
Shoes before discount: Fancy Shoes for $120.00
Shoes after discount: Fancy Shoes for $108.00
Shoes after 3 discounts: Fancy Shoes for $87.48</programlisting>

            </section>

            <section xml:id="commons-base-functors-closure-discussion">
                <title>Discussion</title>

                <para>A <code>Closure</code> operates on the input object passed 
                to the <code>execute( )</code> method. There is no need to modify
                the object but generally that is the case as the method does not 
                have a return value the only way to give information back to the
                caller is with the input object.</para>
                <para>Another common use of this type of object is to pass it 
                as a <emphasis role="bold">call back object</emphasis>. When we
                need to do an asyncronous operation we pass a <code>Closure</code>
                so it is call with the answer of the operation. And as the closures
                can be composed (as the rest of the functors), the "<code>Closure</code>""
                could actually be a list of closures working together to obtain 
                the expected result. </para>
                 
                <para>The following table shows <emphasis role="bold">Zauber Commons</emphasis> 
                implementations for <code>Closure</code></para>
                <table frame='hsides'>
                    <title>Closure implementations</title>
                
                    <tgroup cols="2">
                        <thead>
                            <row>
                                <entry align="center">Name</entry>
                                <entry align="center">Description</entry>
                            </row>
                        </thead>

                        <tbody>
                            <row>
                                <entry>
                                    <code>NullClosure</code>
                                </entry>
                                <entry>Does nothing (nop function).</entry>
                            </row>
                            <row>
                                <entry>
                                    <code>ComposeClosure</code>
                                </entry>
                                <entry>Executes every closure in the list passed 
                                via constructor on the object.</entry>
                            </row>
                            <row>
                                <entry>
                                    <code>ErrorLoggerWrapperClosure</code>
                                </entry>
                                <entry>
                                Wraps the execution of another closure and
                                it the inner closure throws an exception this
                                closure catches logs it and rethrows it wrapped
                                in an <code>UnhandledException</code>. 
                                Useful for beeing an outer closure in a threadpool.
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <code>ExecutorClosure</code>
                                </entry>
                                <entry>Closure that delegates its execution to an 
                                <code>Executor</code> given by constructor 
                                (probably in other thread).</entry>
                            </row>
                            <row>
                                <entry>
                                    <code>FilteredClosure</code>
                                </entry>
                                <entry>Aplies a <code>Closure</code> depending on 
                                a <code>Predicate</code> passed via constructor. 
                                Two instances of <code>Closure</code> can be passed 
                                by constructor, one to be executed on true and the other
                                on false.</entry>
                            </row>
                            <row>
                                <entry>
                                    <code>ListClosure</code>
                                </entry>
                                <entry>Stores the objects passed in the <code>execute()</code> 
                                call in a list. These can be retrieved by method <code>getList()</code></entry>
                            </row>
                            <row>
                                <entry>
                                    <code>MutableClosure</code>
                                </entry>
                                <entry>Wrapper closure that delegates into another
                                closure that can be change on using method 
                                <code>setTarget()</code> and passing a new
                                <code>Closure</code>.</entry>
                            </row>
                            <row>
                                <entry>
                                    <code>SwitchClosure</code>
                                </entry>
                                <entry>Takes a list of <code>PredicateClosureEntry</code> 
                                (entries with predicates as keys and closures as values) 
                                via constructor and on the <code>execute</code> call 
                                goes through the list evaluating the input object
                                with the Predicates executing closure associated
                                with the first <code>Predicate</code> that
                                evaluates to true.</entry>
                            </row>     
                            <row>
                                <entry>
                                    <code>TargetTransformerClosure</code>
                                </entry>
                                <entry>Transforms it's input using a <code>Transform</code>
                                object and then delegate the new object to an instance of
                                <code>Closure</code>. Both objects are passed 
                                via constructor.</entry>
                            </row>                                 
                        </tbody>
                    </tgroup>
                </table>                
                
            </section>   
            <!-- TODO Closure Processors -->         
        </section>
        
    </section>
    
    <section xml:id="commons-base-exception">
        <title>Useful Exceptions</title>
        <para>The following table shows the most frequently used exceptions</para>
        <!-- TODO making a paragraph to talk about the TriggeredExceptionBuilder -->
        <!-- Use javadoc and https://wiki.zaubersoftware.com/intra/bin/view/Commons/ReleasesNotes3Punto21 -->        
        <table frame='hsides'>
            <title>Exceptions</title>
        
            <tgroup cols="2">
                <thead>
                    <row>
                        <entry align="center">Name</entry>
                        <entry align="center">Description</entry>
                    </row>
                </thead>

                <tbody>
                    <row>
                        <entry>
                            <code>AbstractEntityException</code>
                        </entry>
                        <!-- Taken from javadoc -->
                        <entry> It is designed to be extended. It may be rare only 
                        extend the class to change the semantic but not its behavior. 
                        This is much better than having an enum in the constructor. 
                        This solution is most elegant.</entry>
                    </row>
                    <!-- TODO the next two exceptions are not following 
                    the Exception ending convention -->
                    <row>
                        <entry>
                            <code>InvalidPassword</code>
                        </entry>
                        <entry>Indicates the entry of an invalid password.</entry>
                    </row>
                    <row>
                        <entry>
                            <code>CharLengthInvalidPassword</code>
                        </entry>
                        <entry>Allows to identify an invalid length password.</entry>
                    </row>
                    <row>
                        <entry>
                            <code>DuplicatedEntityException</code>
                        </entry>
                        <entry>The entry is duplicated.</entry>
                    </row>
                    <!-- Mispelled entity -->
                    <row>
                        <entry>
                            <code>InsertionEntintyException</code>
                        </entry>
                        <!-- TODO add description -->
                        <!-- 
                        <entry>No description here</entry>
                         -->
                    </row>
                    <row>
                        <entry>
                            <code>NoSuchEntityException</code>
                        </entry>
                        <entry>Indicates that the entity does not exist.</entry>
                    </row>
                    <row>
                        <entry>
                            <code>TriggeredException</code>
                        </entry>
                        <entry>Exception thrown by <code>TriggeredExceptionBuilder</code></entry>
                    </row>
                </tbody>
            </tgroup>
        </table>                

    </section>    
    
    <section xml:id="commons-base-secret">
        <title>Secrets Handling</title>
        <section xml:id="commons-base-secret-problem">
            <title>Problem</title>
            
	        <para>Let's assume that we need to verify user's email address in some 
	        web project. For these we will send him an email to the unverified email 
	        account with a link to our system in order to confirm the address. 
	        Obviously we will need some kind of code for this unique action to be 
	        secure. Here it is where <code>SecretMap</code> comes in.</para>
	        
        </section>
        <section xml:id="commons-base-secret-solution">
            <title>Solution</title>
            <para>We need some class that handles a relationship between 
            my user and a secret code. <code>SecretMap</code> is fulfilling that 
            role. Also this class provides a way to determine the date of expiration
            for that secret to be used. Some methods defined on <code>SecretMap</code> interface are:</para>
            <programlisting language="Java">
public interface SecretsMap&lt;T&gt; {

    // Creates a new secret for object T. If object T had a previus secret, it
    // becomes replaced by the new.
    // The secret must be unique (in the scope of each instance)
    String register(T obj, Date expirationDate);

    // Register a new secret, using the default expiration schema
    String register(T t);
    
    // Makes invalid the current secret for a T. If he didn't have a secret
    // nothing happens.
    void unregister(T t);

    // Peeks a secret
    String peekSecret(T t) throws NoSuchEntityException;

    // Returns the secret for object T and if it doesn't exist, registers T 
    // and returns a new secret. 
    String safeGetSecret(T t);

    // Given a secret, retrieves T.
    T getT(String secret) throws NoSuchEntityException;

    // Removes all secrets belonging to a key. Implementation
    // decides how to match the key.
    void removeByKey(String key);
     
    // Get all the objects Ts that belongs to a key. Implementation
    // decides how to match the key.
    T getByKey(String key);
     
    // Removes secrets that has expired.
    void cleanup();
}</programlisting>
            <para>Now, we have an interface to ask for secrets and 
            retrieving the user associated with them. In our example we want to 
            verify an user's email address. First, we should register the user in our 
            <code>SecretMap</code> and send him the email with some link including 
            that secret as a url parameter. Then, our controller should take 
            that secret, retrieve the user, verify him and remove the entry from 
            the map.</para>
        </section>
        <section xml:id="commons-base-secret-implementation">
            <title>Implementation</title>
            <para>For secret handling also we need to determine how secrets 
            will be generated and their's expiration policy. For these purposes 
            there are three more interfaces <code>SecretGenerator</code>, 
            <code>ExpirationDatePolicy</code> and <code>ExpirationDateValidator</code>.
            Knowing their function and available implementations of each one 
            should be sufficient for complete understanding of secret customization 
            and future additions or modifications in the API.</para>
	        <table frame='hsides'>
	            <title>Interfaces involved</title>
	        
	            <tgroup cols="3">
	                <thead>
	                    <row>
	                        <entry align="center">Interface</entry>
	                        <entry align="center">Function</entry>
	                        <entry align="center">Available implementations</entry>
	                    </row>
	                </thead>
	
	                <tbody>
	                    <row>
	                        <entry>
	                            <code>SecretGenerator</code>
	                        </entry>
	                        <entry>Determines how a secret will be generated. 
	                        This involves the sequence of strings to be generated.</entry>
	                        <entry><code>SecuencialSecretGenerator</code>, 
	                        <code>SecureRandomSecretGenerator</code></entry>
	                    </row>
                        <row>
                            <entry>
                                <code>ExpirationDatePolicy</code>
                            </entry>
                            <entry>Policy of expiration dates. Policy of time 
                            in which the secrets expire.</entry>
                            <entry><code>CurrentTimeExpirationDatePolicy</code>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <code>ExpirationDateValidator</code>
                            </entry>
                            <entry>Validates that dates didn't expired.</entry>
                            <entry><code>DaysExpirationDatePolicy</code></entry>
                        </row>                        
	                </tbody>
	           </tgroup>
	        </table>
	        <para>For more information of available implementations, see Javadoc.</para>
	        <para>Up this point we have seen all the logic needed to make use of 
	        the API but not to put it on practice. To start using secrets we can make 
	        use of an available implementation of <code>SecretMap</code> like 
	        <code>JavaUtilMapSecretsMap</code> or have our own, by extending 
	        <code>AbstractSecretsMap</code> which already has logic for this
	        purpose.</para>
	        <section>
	           <title>Simple code example</title>
	           <para>First, the secret map generation which should be in some 
	           service.</para>
<programlisting language="Java">// Defining the secuence that should be used for secret's generation
SecretGenerator sg = new SecureRandomSecretGenerator(new SecureRandom());

// Map for registering secrets in asociation with our system's user
Map&lt;String, User&gt; secretsMap = new Map&lt;String, User&gt;();

// Map for registering expiration dates
Map&lt;User, Date&gt; expirationDateMap = new Map&lt;User, Date&gt;();

// Set the expiration policy, valid for two days 
ExpirationDatePolicy edp = new DaysExpirationDatePolicy(2);

// Validates that the expiration date against the local machine clock
ExpirationDateValidator edv = new CurrentTimeExpirationDateValidator();

// Creation of secret map
SecretMap sm = 
    new JavaUtilMapSecretsMap(sg, secretsMap, expirationDateMap, edp, edv);
</programlisting>
                <para>Second, logic for storing requests on email verification.</para>
<programlisting language="Java">User user = getUser();

// Register the user's request for email verification in the map 
String secretId = sm.register(user);

//Send to the email with the secure action id
sendEmailWithLink("http://www.mysite.com?secret=" + secretId);
</programlisting>
                <para>Finally, we are retrieving the user with the secret given 
                as parameter and set as a verified user.</para>
<programlisting language="Java">User user = null;
String secret = request.getParameter("secret");

try {
    user = sm.getT(secret);
    user.setVerified(true);
} catch (NoSuchEntityException exc) {
    //Some logic
}</programlisting>
	        </section>
        </section>
        <!-- TODO maybe a complex example with spring integration -->
        
        
    </section>    

    <section xml:id="commons-base-utils">
        <title>String, Date, Password and Validation Utils</title>
        <para>This section show how to use different utils that are useful
        for developing like latin related string utils, password encoders, 
        validators and date utils.</para>
        <section xml:id="commons-base-utils-date">
            <title>Date Utils</title>

            <para>There are two main classes in <emphasis role="bold">Zauber Commons</emphasis> 
            to help using Java <code>Date</code>. The first is <code>ISODateUtils</code>
            which is a helpful class for handling ISO format dates: parsing from strings, 
            retrieving ISO formaters or making an ISO formated date string from 
            a <code>Date</code> object. The second is not a helper class, but 
            an interface to be extended. <code>DateProvider</code> 
            provides a <code>Date</code> object depending on the implementation
            This interface is defined:
            </para>

<programlisting language="Java">
public interface DateProvider {
    // Provides a date
    Date getDate();
}</programlisting>

	        <para>Actually, there are three implementations of <code>DateProvider</code>:</para>
	
	        <itemizedlist>
	            <listitem><para><emphasis role="bold">CurrentDateProvider
	            </emphasis>: Returns the current date.</para></listitem>            
	            <listitem><para><emphasis role="bold">InmutableDateProvider
	            </emphasis>: Returns a new <code>Date</code> with same value 
	            as the inmutable date passed as parameter.</para></listitem>
	            <listitem><para><emphasis role="bold">SignificantDateProvider
	            </emphasis>: Cut the date after the last significant digit. E.x: 
	            2010-03-03 19:54:22 returns 2010-03-03 00:00:00.</para></listitem>
	        </itemizedlist>       
        </section>
        <section xml:id="commons-base-utils-string">
            <title>Latin String Utils</title>
            <para><code>LatinStringUtils</code> is a helper class that 
            provides a method for removing accents from characters.</para>
        </section>
        <section xml:id="commons-base-utils-password">
            <title>Password Related Utils</title>
            <para>Provides interfaces for password encoding and validation. 
            The following table shows implementations for <code>PasswordEncoder</code>
            and <code>PasswordValidator</code>:
            </para>
            <table frame='hsides'>
                <title>Password Validators and Encoders</title>
        
                <tgroup cols="2">
                    <thead>
                        <row>
                            <entry align="center">Name</entry>
                            <entry align="center">Description</entry>
                        </row>
                    </thead>

                    <tbody>
                        <row>
                            <entry>
                                <code>AlwaysValidPasswordValidator</code>
                            </entry>
                            <entry>Skip validation, returning always true.</entry>
                        </row>
                        <row>
                            <entry>
                            <code>CharLengthPasswordValidator</code>
                        </entry>
                        <entry>Validates string's length of password.</entry>
	                    </row>
	                    <row>
	                        <entry>
	                            <code>NullPasswordEncoder</code>
	                        </entry>
	                        <entry>No encoding is done.</entry>
	                    </row>
	                    <row>
	                        <entry>
	                            <code>UnixCrypyPasswordEncoder</code>
	                        </entry>
	                        <entry>Encodes with Unix function <code>Crypt()</code>.</entry>
	                    </row>
	                </tbody>
	            </tgroup>
	        </table>                            
        </section>
        <section xml:id="commons-base-utils-validate">
            <title>Validation</title>
            <para><code>Validate</code> in <emphasis role="bold">Zauber Commons</emphasis>
            is an extension from <emphasis>Apache's Validate</emphasis>. 
            Incorporates variable arguments to methods <code>notNull()</code> and
            <code>notBlank()</code>. Following this, also adds ways of retrieving
            which object has returned the error.</para>
        </section>

    </section>

    <section xml:id="commons-base-resource">
        <title>Resource</title>
        <para>Resource is an attempt to replace 
        <emphasis>Spring</emphasis>'s <code>Resource</code> class
        which purpose is to abstract from the actual type of underlying resource, 
        such as a file or class path resource. Actually there are two implementations
        of <code>Resource</code>: <code>ClasspathResource</code> and <code>StringResource</code>.
        The <code>Resource</code> interface is defined:
        </para>  
        <programlisting>
public interface Resource {

    // Resource Name
    String getName();
    
    // Stream for the resource
    InputStream getInputStream();

    // Last-modified timestamp for this resource.
    Date getLastModified();
}</programlisting>
    </section>    

    <section xml:id="commons-base-collections">
        <title>Collections</title>
        This section introduces utilities for handling collections. There are four classes in this package:
        <itemizedlist>
            <listitem><para><code>DistinctIterator
            </code>: Iterator implementation that eliminates consecutive 
            repeated elements.</para></listitem>            
            <listitem><para><code>DynamicSortedCollection
            </code>: Collection whose order can change dynamically by setting a
            new comparator and it is reordered.</para></listitem>
            <listitem><para><code>OnModificationProxyCollection
            </code>: Abstract class that let us define preprocessing and 
            postprocessing methods on add and remove collection functionallity.</para></listitem>
            <listitem><para><code>OnModificationProxyList
            </code>: Same as above but using lists</para></listitem>
        </itemizedlist>            
    </section>    
    <section xml:id="commons-base-storage">
	<title>Storage</title>
	<section xml:id="commons-base-storage-problem">
		<title>Problem</title>
		<para>Let's say you've got different types of information containers and you'd like to search an specific entity/value/information identified by a key which is in one or many of them but you need the search to be asyncronic. First you should need something to represent the information container in which to search and store. Then, there must be an entity that has the logic to search within the different levels and save the information fetched returning the control to the original context when it had finished. </para>
	</section> 
	<section xml:id="commons-base-storage-solution">	
		<title>Solution</title>
		<para>There 2 entities that helps you resolve this problem. The first one is the Storage entity that represents the basic model of this solution:</para>
<programlisting language="Java">public interface Storage&lt;K, V&gt; {
    
    /** Saves the value for the key specified */
    void store(K key, V value);
    
}
</programlisting>
		<para>As you can see the Storage entity will save the pair (key, value) in the concrete structure it implements.</para>

		<para>The other entity specifies the strategy for saving the pair, this is the ChainedStorageFetcher which uses the Composite Pattern. Its purpose is to chain different Storage entities searching the key passed as a parameter in the StorageChainedFetcher it contains. This should be recursive until the information is found or the chain is over. If the fetcher succeeds, it finally should save the information in the Storage passed as a parameter. Because the original context is always present in every fetch, the control can always be returned to it.</para>
<programlisting language="Java">/**
 * This interface lets chain {@link Storage} checking whether a
 * {@link Storage} has the pair belonging to the specified key. 
 * If this is not the case, it calls the method
 * {@link #fetch(Object, Storage)} from a contained {@link ChainedStorageFetcher} 
 * passing itself as a parameter in order for its original method 
 * {@link #store(Object, Object)} to be called if the pair is found.
 * 
 * @param &lt;K&gt; identifier type
 * @param &lt;V&gt; information type
 * 
 */
public interface ChainedStorageFetcher&lt;K, V&gt; extends Storage&lt;K, V&gt; {
    /**
     * Chained search. If found, calls
     * {@link #store(Object, Object)} from the parent.
     * 
     * @param parentStorage
     *            a {@link Storage} used as a container for the information found.
     * @throws IllegalArgumentException
     *            if the parentStorage is null
     */
    void fetch(K key, Storage&lt;K, V&gt; parentStorage);
}
</programlisting>
	</section>
	<section xml:id="commons-base-storage-implementation">	
		<title>Implementation</title>
		<para>You can find an abstract implementation that can be very useful. It provides a basic 'fetch' method implementation using another contained child StorageChainedFetcher for searching the information associated with the specified key. When found, the value is saved in the Storage entity passed as a parameter when fetching (called parent) and in the fetcher itself:</para>
<programlisting language="Java">public abstract class AbstractChainedStorageFetcher&lt;K, V&gt; 
    implements ChainedStorageFetcher&lt;K, V&gt; {
    private final ChainedStorageFetcher&lt;K, V&gt; child;
    private Storage&lt;K, V&gt; parent;

    /** Creates the AbstractChainedStorageFetcher. */
    public AbstractChainedStorageFetcher(final ChainedStorageFetcher&lt;K, V&gt; child) {
        Validate.notNull(child);
        this.child = child;
    }

    /** @see ChainedStorageFetcher#fetch(Object, Storage) */
    public final void fetch(final K key, final Storage&lt;K, V&gt; parentStorage) {
        Validate.notNull(parentStorage);
        this.parent = parentStorage;

        V value = this.get(key);
        if (value != null) {
            this.parent.store(key, value);
        } else {
            child.fetch(key, this);
        }
    }

    /** @see Storage#publish(Object) */
    public final void store(final K key, final V value) {
        this.put(key, value);
        this.parent.store(key, value);
    }

    /** Get the value for the specified key */
    protected abstract V get(K key);

    /** Save the pair key, value */
    protected abstract void put(K key, V value);
}
</programlisting>
		<para>We also provide a concrete implementation which extends the abstract described above. It defines the structure for saving the pair (key, value) as a memory map:</para>
<programlisting language="Java">public class MapBasedChainedStorageFetcher&lt;K, V&gt; extends
        AbstractChainedStorageFetcher&lt;K, V&gt; {

    private final Map&lt;K, V&gt; repository;

    /** Creates the MapBasedChainedStorageFetcher. */
    public MapBasedChainedStorageFetcher(
            final ChainedStorageFetcher&lt;K, V&gt; child, final Map&lt;K, V&gt; initialMap) {
        super(child);
        repository = initialMap;
    }

    /** @see AbstractChainedStorageFetcher#get(Object) */
    @Override
    protected final V get(final K input) {
        return repository.get(input);
    }

    /** @see AbstractChainedStorageFetcher#put(Object, Object) */
    @Override
    protected final void put(final K input, final V output) {
        this.repository.put(input, output);
    }
}
</programlisting>
<para>Finally, we created an implementation that mixes Closure with Storage. It delegates the fetching to its contained fetcher but instead of saving the information found, it executes the closure with which it was constructed passing the information as a parameter:</para>
<programlisting language="Java">public class ChainedStorageTransformerClosure&lt;K, V&gt; implements Storage&lt;K, V&gt;,
        Closure&lt;K&gt; {

    private final ChainedStorageFetcher&lt;K, V&gt; child;
    private final Closure&lt;V&gt; target;

    /** Creates the ChainedStorageTransformerClosure. */
    public ChainedStorageTransformerClosure(
            final ChainedStorageFetcher&lt;K, V&gt; child, final Closure&lt;V&gt; target) {
        super();
        Validate.notNull(target);
        Validate.notNull(child);
        this.child = child;
        this.target = target;
    }

    /** @see Closure#execute(Object) */
    public final void execute(final K key) {
        child.fetch(key, this);
    }

    /** @see Storage#store(Object, Object) */
    public final void store(final K key, final V value) {
        target.execute(value);
    }
}
</programlisting>
	</section>
	<section xml:id="commons-base-storage-example">	
       		<title>Example</title>
<para>We show a simple example on how to create some of the fetcher entities and the expected results:</para>
<programlisting language="Java">/*Creating result list with information fetched*/        
final List&lt;String&gt; result = new LinkedList&lt;String&gt;();

/*Creating closure that will be executed when the fetcher finds the information.*/
/*It adds the result in the list above*/
final Closure&lt;String&gt; c = new Closure&lt;String&gt;() {

    @Override
    public void execute(String t) {
        result.add(t);
    }
    
};

/*Defining fetcher default called if no information is found in the parent fetcher.*/
/*It stores the word 'default' no matter if the key is found*/
final ChainedStorageFetcher&lt;Integer, String&gt; defaultFetcher = new
ChainedStorageFetcher&lt;Integer, String&gt;() {

    private Storage&lt;Integer, String&gt; parentStorage;
    
    @Override
    public void fetch(Integer key,
            Storage&lt;Integer, String&gt; parentStorage) {
        this.parentStorage = parentStorage;
        parentStorage.store(key, "default");
    }

    @Override
    public void store(Integer key, String value) {
        this.parentStorage.store(key, value);
    }
};

/*Creating basic repository with keys, information associated*/
final Map&lt;Integer, String&gt; map = new HashMap&lt;Integer, String&gt;();
map.put(1, "example");
map.put(2, "nice");

/*Creating map based fetcher that will search the information required*/
final MapBasedChainedStorageFetcher&lt;Integer, String&gt; mapFetcher =
    new MapBasedChainedStorageFetcher&lt;Integer, String&gt;(defaultFetcher, map);

/*Executing the Closure Fetcher searching the value with key 1*/
new ChainedStorageTransformerClosure&lt;Integer, String&gt;(mapFetcher, c).execute(1);
</programlisting>
<para>We are searching for value with key 1 so the result list is:</para>
<programlisting>
Position Value
0	 example
</programlisting>
<para>Now suppose we execute the closure searching for an inexistent key</para>
<programlisting language="Java">new ChainedStorageTransformerClosure&lt;Integer, String&gt;(mapFetcher, c).execute(3);
</programlisting>
<para>The result list would be:</para>
<programlisting>
Position Value
0	 default
</programlisting>
	</section>    
</section> 
    <section xml:id="commons-base-page-and-order">
        <title>Other general purpose classes</title>
        
        <section xml:id="commons-base-general-purpose-order">
            <title>Ordering</title>
            <!-- Taken from javadoc and -->
            <!-- https://wiki.zaubersoftware.com/intra/bin/view/Commons/ReleasesNotes3Punto17 -->
            <para>There are classes defined to handle the order in Collections. 
            <code>Order</code> class represents an specified order by telling 
            ascending or descending order and the name of the field (java.util.String).</para>
            <para><code>Ordering</code> is a class composed by a list of <code>Order</code>
            to define in each field if it is ascending or descending. 
            We can make use of <code>OrderingBuilder</code> for a more human use. 
            Before if we wanted users in ascending orden, then ascending ignoring 
            case by username, then descending by points and finally descending 
            ignoring case by foo, we had to do:</para>
            
            <programlisting language="Java">
final Ordering expected = new Ordering(
           new Order("name"), 
           new Order("username", true, true),
           new Order("points", false), 
           new Order("foo", false, true));</programlisting>
                                 
            <para>Now this can be done, using builder pattern, by doing: </para>
            
           <programlisting language="Java">
final Ordering ordering = Ordering.builder()
          .asc("name")
          .ascIgnoringCase("username")
          .desc("points")
          .descIgnoringCase("foo")
          .ordering();</programlisting>
        </section>
        <section xml:id="commons-base-general-purpose-paging">
            <title>Paging</title>
	        <para>Class that keeps information related to paging. There are two 
	        constructors that can be used: </para>
            <itemizedlist>
                <listitem><para><code>Paging(Integer pageNumber, 
                Integer resultsPerPage)</code></para></listitem>
                <listitem><para><code>Paging(Integer pageNumber, Integer 
                resultsPerPage, boolean loadResultSize)</code></para></listitem>
            </itemizedlist>
            <para>We should use the first one if we want to use <code>loadResultSize</code> 
            default value (which is true). Parameters should be understood:</para>  	        
	        <itemizedlist>
	            <listitem><para><emphasis role="bold">pageNumber
	            </emphasis>: Current page number.</para></listitem>            
	            <listitem><para><emphasis role="bold">resultsPerPage
	            </emphasis>: Results that are shown by page.</para></listitem>
	            <listitem><para><emphasis role="bold">loadResultSize
	            </emphasis>: Load result size.</para></listitem>
	        </itemizedlist>   	        

        <para>No much more to mention about the <code>Paging</code> object. 
        You should use it instead of passing values between classes.
        </para>    
        </section>
	    <section xml:id="commons-base-general-purpose-rankeable">
	        <title>Rankeable Result</title>
	        <para><code>RankeableResult</code> purpose is to represent a search 
		result which has an associated ranking. It's basically an entry of a result list like the following where, e.g. each user has an associated rank of points:</para>
		<programlisting>
John  120 
Peter 100
...
Mary 10</programlisting>
		<para>In order to create it, you must specify the entity to wrap and the number of hits or rank:</para>
		<itemizedlist>
		 	<listitem><para><code>public InmutableRankeableResult(final Number hits, final T result);</code></para> </listitem>
 		</itemizedlist>
		<para><emphasis>Tip:</emphasis> This entity is very useful when representing each result list's entry found by a hibernate query which uses aggregators. The rank or number of hits should be taken from the chosen aggregator. The result entity acts as a lazy-proxy with its minimum information, ready to complete the load if any other methods are called.</para>
	    </section>
	    <section xml:id="commons-base-general-purpose-iterableMerger">
	        <title>Iterable Merger</title>
	        <para><code>Iterable Merger</code>, as the name implies, merges 2 Iterable objects aplying a Closure to each element priorizing the elements from the first Iterable object received as parameter. In the following example we explain how you can create and invoke Iterable Merger:</para>
<programlisting language="Java">//Create two iterable objects with numbers
Iterable&lt;Integer&gt; iterableLeft = Arrays.asList(52, 64, 79);
Iterable&lt;Integer&gt; iterableRight = Arrays.asList(33, 21, 15);

//Create the list in which the results will be stored
final List&lt;Integer&gt; ret = new LinkedList&lt;Integer&gt;();

//Create a simple Closure that will complete the list with results
Closure&lt;Integer&gt; target = new Closure&lt;Integer&gt;() {
        public void execute(final Integer t) {
                ret.add(t);
        }
 };

//The numbers will be compared and ordered by the closest to fifty
Comparator&lt;Integer&gt; comparator = new Comparator&lt;Integer&gt;() {
        public int compare(final Integer o1, final Integer o2) {
                Integer d1 = Math.abs(50 - o1);
                Integer d2 = Math.abs(50 - o2);
                return d1.compareTo(d2);
        }
};

//Merging
new IterableMerger&lt;Integer&gt;(comparator, target)
            .merge(iterableLeft, iterableRight);
</programlisting>
<para>Here's the merged expected result:</para>
<programlisting>
Number  Distance to 50
52      2
64      14
33      17
79      29
21      29
15      35
</programlisting>
	    </section>               
                    
    </section>    
</chapter>

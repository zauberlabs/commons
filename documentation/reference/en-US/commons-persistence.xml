<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<chapter xml:id="commons-persistence" 
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:ns="http://docbook.org/ns/docbook">
    <title>Commons Persistence</title>
    
    <section xml:id="commons-persistence-overview">
        <title>Overview</title>
         <para><emphasis role="bold">Commons Persistence</emphasis> is an abstract layer upon the data base and the domain model. If you're using an ORM, It aims to be upon it too making the application independent from the ORM used and each of their particular characteristics. What's more, its main purpose is to lower the data access complexity.</para>
        <para>Commons Persistence can be divided in:
        </para>
        <itemizedlist>
            <listitem><para><emphasis role="bold">Api:
            </emphasis>uselful interfaces when persisting an object.</para></listitem>    
	    <listitem><para><emphasis role="bold">Utils:
            </emphasis>utility persistence classes</para></listitem>
	    <listitem><para><emphasis role="bold">Closures:
            </emphasis>handling transactions by theyself executing a closure in between</para></listitem>      
        </itemizedlist>          
    </section>
        
    <!-- Herramientas que tienen que ver con la persistencia -->

    <!-- Mencionar common auth : wrapper por ej, para spring acegi , me brinda
    la posibilidad de manejar genericamente los usuarios -->

    <!-- Interceptores relacionados con hibernate -->

    <!-- 
    Clases de la api
    Nameable = objeto nombrable [getName]
    CreationAuditable = Provee auditoria para la creacion
    Identifiable = objeto identificable [getId]
    LogicallyDeleteable = Objecto que puede ser dado de baja logicamente
    Modifiable = Maneja versionado de un objeto que es mutable
    ModificationAuditable = Provee auditoria para la modificacion
     -->
<section xml:id="commons-persistence-api">
	<title>Api</title>

	<section xml:id="commons-persistence-api-identifible">
		<title>Identifiable</title>
<para><code>Identifiable</code> represents a persistent object identified by a primary key. Here is the simple API it provides. You can implement the id as you wish.</para>
<programlisting language="Java">public interface Identifiable {
    
    /** @return el identificador, or null if it is transient.  */
    Serializable getId();
}</programlisting>
	</section>
<section xml:id="commons-persistence-api-nameable">
		<title>Nameable</title>
<para><code>Nameable</code> represents a persistent object with id and name.</para>
<programlisting language="Java">public interface Nameable extends Identifiable {
    /** @return entity name */
    String getName();
}</programlisting>
	</section>
	<section xml:id="commons-persistence-api-creationauditable">
		<title>Creation Auditable</title>
<para><code>Creation Auditable</code> must be implemented by those entities that require creation audit</para>
<programlisting language="Java">public interface CreationAuditable {

    /**
     * @return responsable for the object creation 
     */
    String getCreatedBy();
    
    /**
     * @return date when the object was created
     */
    Date getCreatedAt();
    
}
</programlisting>
	</section>
<section xml:id="commons-persistence-api-modifiable">
		<title>Modifiable</title>
<para><code>Modifiable</code> must be implemented by entities that can be modified, it defines the object version.</para>
<programlisting language="Java">public interface Modifiable {

    /**
     * @return object version
     */<para><code>Remove</code> is not implemented by now.</para>
    Long getVersion();
    
    /**
     * @param object version
     */
    void setVersion(Long version);
    
}
</programlisting>
	</section>
<section xml:id="commons-persistence-api-modifiable-auditable">
		<title>Modification Auditable</title>
<para><code>Modification Auditable</code> must be implemented by entities that require modification audit.</para>
<programlisting language="Java">public interface ModificationAuditable extends Modifiable {

    /**
     * @return responsable for last modification
     */
    String getModifiedBy();
    
    /**
     * @return when the object was last modified 
     */
    Date getModifiedAt();
        
}
</programlisting>
	</section>
<section xml:id="commons-persistence-api-logically-deleted">
		<title>Logically Deleteable</title>
<para><code>Logically Deleteable</code> must be implemented by entities that can be logically deleted</para>
<programlisting language="Java">public interface LogicallyDeleteable {
    
    /** set if the object is logically deleted */
    void setLogicallyDeleted(boolean logicallyDeleted);
    
    /** @return true if the object is logically deleted  */
    boolean isLogicallyDeleted(); 
    
}
</programlisting>
	</section>

</section>
    
    <!-- 
    Clases de utils
    ScrollableResultsIterator
    -->
<section xml:id="commons-persistence-utils">
	<title>Utils</title>
	<para>We introduce some utils classes related to object persistence. By now, we only have the following:</para>

        <itemizedlist>
            <listitem><para><emphasis role="bold"><code>ScrollableResultIterator:</code>
            </emphasis>an iterator that works with Hibernate <code>ScrollableResult</code>.</para>
<itemizedlist>
<listitem>
<para><code>next</code> returns the actual element and advances next element after that to prepare the following actual element (the constructor initializes the actual element with the first in ScrollableResult). It evicts from Hibernate session the next element to return at the following next if there's any. If there're no more elements, method next assigns the actual element null and in the following called returns <code>NoSuchElementException</code>.</para>
</listitem>
<listitem>
<para><code>hasNext</code> returns whether the actual element poped out from the ScrollableResult is null. </para>
</listitem>
<listitem>
<para><code>remove</code> is not implemented by now.</para>
</listitem>
</itemizedlist>
	    </listitem>            
        </itemizedlist>    
</section>

    <!--**Closures -> Tienen que ver con el Open Session in view
    Donde spring abre la sesion (cuando le llega el request mediante un interceptor
    y dps la cierra)
    
    Ver clase OpenEntityManagerInViewFilter de springframework
    
    En este caso se aplica la misma logica que usa spring para poder usar en otros
    contextos (mediante un closure o soporte para runnables)
    
    OpenEntityManagerClosure
    OpenEntityManagerRunnable
    OpenSessionClosure
    -->
<section xml:id="commons-persistence-closures">
	<title>Closures</title>
	<para>We've implemented some clases to wrap any piece of code execution between a transaction as the Spring <code>OpenSessionInViewFilter</code> does.</para>
 <itemizedlist>
        <listitem>
	<para><emphasis role="bold"><code>OpenEntityManagerClosure:</code></emphasis> receives the <code>EntityManagerFactory</code> that will create the <code>EntityManager</code> to operate with, the <code>Closure</code> to execute between the transaction and a dryrun parameter that indicates whether to manage a new transaction or just execute the closure without any new context (this is typically the case of test context which already provides a transaction management itself):</para>
<programlisting language="Java">public OpenEntityManagerClosure(final EntityManagerFactory emf,
            final Closure&lt;T&gt; target, final boolean dryrun);
</programlisting>
</listitem> 
<listitem>
<para><emphasis role="bold"><code>OpenEntityManagerRunnable:</code></emphasis> uses the <code>OpenEntityManagerClosure</code> but executes a new thread instead of any other <code>Closure</code>. Does not provide a way to do dryrun:</para>
<programlisting language="Java">public OpenEntityManagerRunnable(final EntityManagerFactory emf,
            final Runnable target);
</programlisting>
</listitem> 
<listitem>
<para><emphasis role="bold"><code>OpenSessionClosure:</code></emphasis> is exactly like <code>OpenEntityManagerClosure</code> but instead of using the <code>EntityManager</code>, works directly with <code>Hibernate Session</code>:</para>
<programlisting language="Java">public OpenSessionClosure(final SessionFactory sessionFactory,
            final Closure&lt;T&gt; target, final boolean dryrun);
</programlisting>
	</listitem>
        </itemizedlist>
</section>
    <!--**Utils -> 
    AnonymousAuthenticationUserMapper

    ConfigurableHibernatePersistence -> recibe un interceptor

    MockHibernateAuditLogger -> para entornos de testing
    
    HibernateAuditLoggerInterceptor -> fijarse  los metodos que implementan
    para ver donde se cuelga cada uno
    SpringInjectionHibernateAuditLoggerInterceptor
    SpringInjectionInterceptor
    
    chequear el ultimo mail de juan de los interceptors... se habla de esto
    https://wiki.zaubersoftware.com/intra/bin/view/Commons/ReleasesNotes3Punto35
    https://wiki.zaubersoftware.com/intra/bin/view/Commons/AboutRepository
     -->
    
</chapter>
